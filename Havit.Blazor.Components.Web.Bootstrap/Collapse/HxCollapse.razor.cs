using Microsoft.JSInterop;

namespace Havit.Blazor.Components.Web.Bootstrap;

/// <summary>
/// <see href="https://getbootstrap.com/docs/5.3/components/collapse/">Bootstrap 5 Collapse</see> component.<br />
/// Full documentation and demos: <see href="https://havit.blazor.eu/components/HxCollapse">https://havit.blazor.eu/components/HxCollapse</see>
/// </summary>
public partial class HxCollapse : IAsyncDisposable
{
	/// <summary>
	/// Element ID. To be referenced by <see cref="HxCollapseToggleButton.CollapseTarget"/>.
	/// (Autogenerated GUID if not set explicitly.)
	/// </summary>
	[Parameter] public string Id { get; set; }

	/// <summary>
	/// Direction of the animation.
	/// Default is <see cref="CollapseDirection.Vertical"/>.
	/// </summary>
	[Parameter] public CollapseDirection CollapseDirection { get; set; }

	/// <summary>
	/// If a parent is provided, then all collapsible elements under the specified parent will be closed when this collapsible item is shown.
	/// (Similar to traditional accordion behavior.)
	/// </summary>
	[Parameter] public string Parent { get; set; }

	/// <summary>
	/// Additional CSS class.
	/// </summary>
	[Parameter] public string CssClass { get; set; }

	/// <summary>
	/// Determines whether the collapse will be open or closed (expanded or collapsed) when first rendered.
	/// </summary>
	[Parameter] public bool InitiallyExpanded { get; set; }

	/// <summary>
	/// Content of the collapse.
	/// </summary>
	[Parameter] public RenderFragment ChildContent { get; set; }

	/// <summary>
	/// This event is fired when a collapse element has become visible to the user (will wait for CSS transitions to complete).
	/// </summary>
	[Parameter] public EventCallback<string> OnShown { get; set; }
	/// <summary>
	/// Triggers the <see cref="OnShown"/> event. Allows interception of the event in derived components.
	/// </summary>
	protected virtual Task InvokeOnShownAsync(string elementId) => OnShown.InvokeAsync(elementId);

	/// <summary>
	/// This event is fired when a collapse element has been hidden from the user (will wait for CSS transitions to complete).
	/// </summary>
	[Parameter] public EventCallback<string> OnHidden { get; set; }
	/// <summary>
	/// Triggers the <see cref="OnHidden"/> event. Allows interception of the event in derived components.
	/// </summary>
	protected virtual Task InvokeOnHiddenAsync(string elementId) => OnHidden.InvokeAsync(elementId);

	/// <summary>
	/// Additional attributes to be splatted onto an underlying <c>div</c> element.
	/// </summary>
	[Parameter(CaptureUnmatchedValues = true)] public Dictionary<string, object> AdditionalAttributes { get; set; }


	[Inject] protected IJSRuntime JSRuntime { get; set; }

	private ElementReference _collapseHtmlElement;
	private DotNetObjectReference<HxCollapse> _dotnetObjectReference;
	private IJSObjectReference _jsModule;
	private string _defaultId = "hx" + Guid.NewGuid().ToString("N");
	private bool _disposed;
	private bool _isShown;
	private bool _showInProgress;
	private bool _hideInProgress;
	private bool _initialized;

	/// <summary>
	/// Indicates ShowAsync() was called before OnAfterRenderAsync (DOM not initialized). Therefore, we will remember the request for Show and initialize the collapse with toggle=true.
	/// </summary>
	private bool _shouldToggle;

	public HxCollapse()
	{
		_dotnetObjectReference = DotNetObjectReference.Create(this);
	}

	public override async Task SetParametersAsync(ParameterView parameters)
	{
		await base.SetParametersAsync(parameters);

		// To be able to use another default value in ancestors (HxNavbarCollapse)
		Id = parameters.GetValueOrDefault(nameof(Id), _defaultId);
	}

	/// <inheritdoc cref="ComponentBase.OnAfterRenderAsync(bool)" />
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{

		await base.OnAfterRenderAsync(firstRender);

		if (firstRender)
		{
			await EnsureJsModuleAsync();
			if (_disposed)
			{
				return;
			}
			await _jsModule.InvokeVoidAsync("initialize", _collapseHtmlElement, _dotnetObjectReference, _shouldToggle);
			_initialized = true;
		}
	}

	protected override void OnInitialized()
	{
		if (InitiallyExpanded)
		{
			_isShown = true;
		}
	}

	/// <summary>
	/// Expands the item.
	/// </summary>
	public async Task ShowAsync()
	{
		if (_initialized)
		{
			await EnsureJsModuleAsync();
			_showInProgress = true;
			await _jsModule.InvokeVoidAsync("show", _collapseHtmlElement);
		}
		else
		{
			_shouldToggle = true;
		}
	}

	/// <summary>
	/// Collapses the item.
	/// </summary>
	public async Task HideAsync()
	{
		await EnsureJsModuleAsync();
		_hideInProgress = true;
		await _jsModule.InvokeVoidAsync("hide", _collapseHtmlElement);
	}

	/// <summary>
	/// Receives notification from JavaScript when item is about to start showing.
	/// </summary>
	[JSInvokable("HxCollapse_HandleJsShow")]
	public void HandleJsShow()
	{
		_showInProgress = true;
	}

	/// <summary>
	/// Receives notification from JavaScript when item is shown.
	/// </summary>
	/// <remarks>
	/// the shown-event gets raised as the "show" CSS class is added to the HTML element and the transition is completed
	/// this covers both user-interaction (DOM state) and Blazor-interaction (HxAccordion.ExpandedItemId change)
	/// </remarks>
	[JSInvokable("HxCollapse_HandleJsShown")]
	public async Task HandleJsShown()
	{
		_isShown = true;
		bool wasInProgress = _showInProgress;
		_showInProgress = false;
		await InvokeOnShownAsync(Id);

		if (wasInProgress)
		{
			// ShouldRender() disables rendering when transitioning from hidden to shown.
			// It therefore needs to be called explicitly after the event is handled.
			StateHasChanged();
		}
	}

	/// <summary>
	/// Receives notification from JavaScript when item is about to hide.
	/// </summary>
	[JSInvokable("HxCollapse_HandleJsHide")]
	public void HandleJsHide()
	{
		_hideInProgress = true;
	}

	/// <summary>
	/// Receives notification from JavaScript when item is hidden.
	/// </summary>
	[JSInvokable("HxCollapse_HandleJsHidden")]
	public async Task HandleJsHidden()
	{
		_isShown = false;
		bool wasInProgress = _hideInProgress;
		_hideInProgress = false;
		await InvokeOnHiddenAsync(Id);

		if (wasInProgress)
		{
			// ShouldRender() disables rendering when transitioning from shown to hidden.
			// It therefore needs to be called explicitly after the event is handled.
			StateHasChanged();
		}
	}

	private async Task EnsureJsModuleAsync()
	{
		_jsModule ??= await JSRuntime.ImportHavitBlazorBootstrapModuleAsync(nameof(HxCollapse));
	}

	protected virtual string GetCssClass()
	{
		return CssClassHelper.Combine(
			"collapse",
			CollapseDirection == CollapseDirection.Horizontal ? "collapse-horizontal" : null,
			_isShown ? "show" : null,
			CssClass);
	}

	protected override bool ShouldRender()
	{
		if (_showInProgress || _hideInProgress)
		{
			// do not re-render if the transition (animation) is in progress
			return false;
		}
		return base.ShouldRender();
	}

	/// <inheritdoc/>

	public async ValueTask DisposeAsync()
	{
		await DisposeAsyncCore();

		//Dispose(disposing: false);
	}

	protected virtual async ValueTask DisposeAsyncCore()
	{
		_disposed = true;

		if (_jsModule != null)
		{
			try
			{
				await _jsModule.InvokeVoidAsync("dispose", _collapseHtmlElement);
				await _jsModule.DisposeAsync();
			}
			catch (JSDisconnectedException)
			{
				// NOOP
			}
			catch (TaskCanceledException)
			{
				// NOOP
			}
		}

		_dotnetObjectReference?.Dispose();
	}
}
